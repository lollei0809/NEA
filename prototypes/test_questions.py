"""import pytest
from questions import UnsignedQuestion
import random

class TestUnsignedQuestion:
    @pytest.fixture
    def unsigned_question(self):
        random.seed(12345678)
        test_question = UnsignedQuestion()
        test_question.generate_question()
        test_question.generate_question_phrase()
        test_question.generate_correct_answer()
        test_question.generate_plausible_answers()
        return test_question

    def test_UQ_setup(self, unsigned_question): #to check any changes to the functions don't affect the questions
                                                # and answers that have been generated by the origional algorithms
                                                #separate into different test functions
        print(unsigned_question)
        random.seed(12345678)
        assert unsigned_question.correct_answer == '01110101'
        assert unsigned_question.num_bits == 8
        assert unsigned_question.question == 117
        assert unsigned_question.question_phrase == "convert this decimal number 117 to unsigned binary"
        assert unsigned_question.question_type == "dtb"

        #check algorithms are generating correct answers


""""""
    def test_UQ


    def test_correct_answer(self, unsigned_question):
        if unsigned_question.question_type == type[1]:
            assert unsigned_question.question >= 0 and unsigned_question <= 255
        if unsigned_question.question_type == type[0]:
            assert len(unsigned_question.question) == 8
            for i in range(unsigned_question.num_bits):
                assert unsigned_question.question[i] in ["0","1"]

    def test_plausible_answers(self, unsigned_question):
        assert len(unsigned_question.plausible_answers) == 3
        assert unsigned_question.plausible_answers #check for duplicates

#boundry case and wrong cases
#concrete examples
"""
import pytest
from questions import UnsignedQuestion, SignAndMagnitude, HexToDec


@pytest.mark.parametrize("type_acr, expected_type", [
    ("dtub", int),
    ("ubtd", str)
])
def test_unsigned_question_generate_question(type_acr, expected_type):
    uq = UnsignedQuestion(type_acr)
    uq.generate_question()
    assert isinstance(uq.question, expected_type)
    if type_acr == "dtub":
        assert 0 <= uq.question <= 255
    else:
        assert len(uq.question) == 8 and set(uq.question).issubset({"0", "1"})


def test_unsigned_question_generate_correct_answer():
    uq = UnsignedQuestion("dtub")
    uq.question = 5
    uq.generate_correct_answer()
    assert uq.correct_answer == "00000101"

    uq = UnsignedQuestion("ubtd")
    uq.question = "00000101"
    uq.generate_correct_answer()
    assert uq.correct_answer == 5


def test_sign_and_magnitude_generate_question():
    sm = SignAndMagnitude("dtsm")
    sm.generate_question()
    assert isinstance(sm.question, int)
    assert -127 <= sm.question <= 127

    sm = SignAndMagnitude("smtd")
    sm.generate_question()
    assert len(sm.question) == 8
    for digit in sm.question:
        assert digit in ["0", "1"]


def test_sign_and_magnitude_generate_correct_answer():
    sm = SignAndMagnitude("dtsm")
    sm.question = -5
    sm.generate_correct_answer()
    assert sm.correct_answer == "10000101"

    sm = SignAndMagnitude("smtd")
    sm.question = "10000101"
    sm.generate_correct_answer()
    assert sm.correct_answer == -5

    sm = SignAndMagnitude("dtsm")
    sm.question = 5
    sm.generate_correct_answer()
    assert sm.correct_answer == "00000101"

    sm = SignAndMagnitude("smtd")
    sm.question = "00000101"
    sm.generate_correct_answer()
    assert sm.correct_answer == 5

    sm = SignAndMagnitude("smtd")
    sm.question = "00000000"
    sm.generate_correct_answer()
    assert sm.correct_answer == 0

    sm = SignAndMagnitude("smtd")
    sm.question = "10000000"
    sm.generate_correct_answer()
    assert sm.correct_answer == 0

    sm = SignAndMagnitude("dtsm")
    sm.question = 0
    sm.generate_correct_answer()
    assert sm.correct_answer in ["00000000", "10000000"]


def test_hex_to_dec_generate_question():
    htd = HexToDec("htd")
    htd.generate_question()
    assert len(htd.question) == 2
    for i in htd.question:
        assert i in "0123456789ABCDEF"

    htd = HexToDec("dth")
    htd.generate_question()
    assert isinstance(htd.question, int)
    assert 0 <= htd.question <= 255


def test_hex_to_dec_generate_correct_answer():
    htd = HexToDec("htd")
    htd.question = "E6"
    htd.generate_correct_answer()
    assert htd.correct_answer == 230

    htd = HexToDec("dth")
    htd.question = 230
    htd.generate_correct_answer()
    assert htd.correct_answer == "E6"

    htd = HexToDec("htd")
    htd.question = "00"
    htd.generate_correct_answer()
    assert htd.correct_answer == 0

    htd = HexToDec("dth")
    htd.question = 0
    htd.generate_correct_answer()
    assert htd.correct_answer == "00"


def test_plausible_answers():
    uq = UnsignedQuestion("dtub")
    uq.question = 10
    uq.generate_correct_answer()
    uq.generate_plausible_answers()
    assert len(uq.plausible_answers) == 3
    assert uq.correct_answer in uq.plausible_answers

    sm = SignAndMagnitude("dtsm")
    sm.question = -5
    sm.generate_correct_answer()
    sm.generate_plausible_answers()
    assert len(sm.plausible_answers) == 3
    assert sm.correct_answer in sm.plausible_answers

    htd = HexToDec("dth")
    htd.question = 15# 15 is 0F in hex so might be only 1 char
    htd.generate_correct_answer()
    htd.generate_plausible_answers()
    assert len(htd.plausible_answers) == 3
    assert htd.correct_answer in htd.plausible_answers


def test_check_answer():
    uq = UnsignedQuestion("dtub")
    uq.correct_answer = "00010001"
    uq.user_answer = "00010001"
    assert uq.check_answer()

    sm = SignAndMagnitude("dtsm")
    sm.correct_answer = "10100101"
    sm.user_answer = "10100101"
    assert sm.check_answer()

    htd = HexToDec("dth")
    htd.correct_answer = "BA"
    htd.user_answer = "BA"
    assert htd.check_answer()
